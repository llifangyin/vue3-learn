<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>vue3源码解析</title>
</head>
<body>
    <div id="app"></div>
    <script type="module">
        import { reactive ,effect, ref,toRef,toRefs,proxyRefs,computed} from './reactivity.js'
        let obj = {
            name: 'lisi',
            age: 18,
            test:'test',
            address:{n:1},
            flag:true
        }
        const state = reactive(obj)

        const aliasName = computed({
            // console.log('runner')
            // return state.name + '==='
            get(oldValue){
                // console.log('runner',oldValue)
                return state.name + '==='
            },
            set(v){
                console.log(v,'v')
            }
        })
        // computed 
        // 1.计算属性具备收集能力，可以收集对应的effect,依赖的值变化后，重新执行effect
        // 2. 计算属性维护了一个dirty属性，默认true,运行一次后变为false,并且稍后依赖的值的变化再次变为true
        // 3. 计算属性也是个effect,依赖的属性会收集这个计算属性,值变化后,会让computedEffect里的dirty变为true


        // 多次访问 只会执行一次
        // console.log(aliasName.value,'aliasName1')
        console.log(aliasName.value,'aliasName2')
        setTimeout(() => {
            state.name = 'wangwu'
            console.log(aliasName.value,'aliasName3')
        }, 1000);



        // const state = reactive(obj)
        // let name = .toRefs(state,'name')
        // let age = toRef(state,'age')
        // console.log(name,age,'name,age');
        
        // const {name,age} = toRefs(state)
        // console.log(name,age,'name,age');
        // let proxyRefsObj = proxyRefs({...toRefs(state)})
        // proxyRefsObj.name = 'wangwu'
        // effect(() => {
        //     // app.innerHTML = `name ${name.value} age ${age.value}`
        //     console.log(proxyRefsObj.name,proxyRefsObj.age,'proxyRefs');
            
        // })
        // const flag = ref({name:'lisi'})
    
        // effect(()=>{
        //     app.innerHTML = flag.value.name
        // })
        // setTimeout(() => {
        //     flag.value.name = 'wangwu'
        //     console.log(flag, 'flag')
        // }, 1000);

        // const flag = ref(true)
        // const firstName = ref('zhang')
        // const lastName = ref('wangwu')
        // effect(()=>{
        //     app.innerHTML = flag.value ? firstName.value + lastName.value:firstName.value + lastName.value + ':'
        // })
        // setTimeout(() => {
        //     flag.value = false
        //     console.log(flag, 'flag')
        // }, 1000);


        // const state = reactive(obj)
        //   state被代理过 一定有get set方法
        // console.log(state == state2, 'state')
        // console.log(state.name, 'state.name')
    //    let runner =  effect(() => {
    //         app.innerHTML = state.flag ? `name ${state.name} test ${state.test}`:` age ${state.age}`
    //         // flag true
    //         // {obj:{flag:{effect},name:{effect}}}
    //         // flag false 不需要name的effect了
    //         // {obj:{flag:{effect},age:{effect}}}
    //         // app.innerHTML = state.flag + state.flag + state.flag
    //     },{
    //         scheduler:()=>{
    //             // 目的不自己更新，数据变化后自己处理如何渲染
    //             // 数据更新了 走自己的逻辑
    //             console.log('数据更新了 走自己的逻辑 scheduler',runner.effect)
    //             runner()
    //         }
    //     })

        // effect(() => {
        //     app.innerHTML = `name ${state.name} `
        // })
        // effect(()=>{
        //     app.innerHTML = state.address.n
        //     // state.name = Math.random()//effect正在执行，先不触发
        // })
        // setTimeout(() => {
        //     state.address.n++
        // }, 1000);
        // setTimeout(() => {
        //     state.flag = false
        //     state.age++
        //     // setTimeout(() => {
        //     //     state.name = 'wangwu' 
        //     //     // 修改后不应该触发effect 因为没有使用
        //     // }, 1000);
        // }, 1000)

        // 需要一个算法，对比不同分支切换的差异
        // {flag,name}  {flag,age}

        // effect(() => {
        //     console.log(state.name, 'state.name')
        //     effect(() => {
        //         console.log(state.name, 'state.name')
        //     })
        //     console.log(state.age, 'state.name')
        // })
        // _effect.run()
    </script>
</body>
</html>